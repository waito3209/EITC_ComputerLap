# -*- coding: utf-8 -*-
"""01_mnist_fc_train.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/17WwIj9Yax7nOvPy1u6MktkhwO17A1yUG

<h1>Import packages<h1>
"""

import numpy as np
import matplotlib.pyplot as plt

# Commented out IPython magic to ensure Python compatibility.
# %matplotlib inline

"""<h1>Load dataset and label into memory<h1>"""

# load dataset into numpy array
from tensorflow.keras.datasets import mnist
(train_images, train_labels), (test_images, test_labels) = mnist.load_data()

print('Training data shape : ', train_images.shape, train_labels.shape)
print('Testing data shape : ', test_images.shape, test_labels.shape)



plt.figure(1,figsize=[10, 5])
# Display the first image in training data
plt.subplot(121)
plt.imshow(train_images[0, :, :], cmap='gray')
plt.colorbar()
plt.title(f"Ground Truth : {train_labels[0]}");

# Display the first image in testing data
plt.subplot(122)
plt.imshow(test_images[0, :, :], cmap='gray')
plt.colorbar()
plt.title(f"Ground Truth : {test_labels[0]}");

plt.show()

# distribution of train images and test images
plt.figure(1)
plt.hist(train_labels, bins=10)
plt.title('Train data')
plt.xlabel('label')
plt.ylabel('count')


plt.figure(2)
plt.hist(test_labels, bins=10)
plt.title('Test data')
plt.xlabel('label')
plt.ylabel('count')

plt.show()

# MINIST image height, width and channel
myHeight = 28
myWidth = 28
myChannel = 1  # gray scale images
myInputShape = (784,)  # a vector
myNClass = 10
myClasses = ['0','1','2','3','4','5','6','7','8','9']

# convert the labels from integers to one hot vectors
from sklearn.preprocessing import LabelBinarizer
lblbin = LabelBinarizer()
train_labels_onehot = lblbin.fit_transform(train_labels)
test_labels_onehot = lblbin.transform(test_labels)

"""<h1>Preprocess images<h1>"""

# reshape the data from (28,28) to (784,)
train_data = train_images.reshape((train_images.shape[0], myHeight*myWidth))
test_data = test_images.reshape((test_images.shape[0], myHeight*myWidth))
print(train_data.shape)
print(test_data.shape)

# scale data to the range of [0, 1]
train_data = train_data.astype("float32") / 255.0
test_data = test_data.astype("float32") / 255.0

"""<h1>Build Our Network Model</h1>"""

# Build our network model
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Activation, Dense

model = Sequential()
model.add(Dense(20, activation='relu', input_shape=myInputShape))
model.add(Dense(20, activation='relu'))
model.add(Dense(myNClass, activation='softmax'))

print( model.summary() )

"""<h1>Compile and train the model</h1>"""

# Compile our model
model.compile(optimizer='rmsprop', loss='categorical_crossentropy',metrics=['accuracy'])

# train the network
print("[INFO] training network...")
EPOCHS = 20
BS = 256
H = model.fit(train_data, train_labels_onehot, batch_size=BS,epochs=EPOCHS, verbose=1,validation_data=(test_data, test_labels_onehot))

"""<h1>Statistic report<h1>"""

# evaluate the trained model from test data
print("[INFO] evaluating network...")
[test_loss, test_acc] = model.evaluate(test_data, test_labels_onehot, verbose=0)
print("Evaluation result on Test Data : Loss = {}, accuracy = {}".format(test_loss, test_acc))

# statistic report of the trained model from test data group by each class
predictions = model.predict(test_data)
from sklearn.metrics import classification_report
# classification_report(Ground true, prediction, class names)
print(classification_report(test_labels, predictions.argmax(axis=1),target_names=myClasses))

"""<h1>Check Overfitting/Underfitting<h1>"""

#Plot the Loss Curves
plt.figure(figsize=[12,12])
plt.plot(H.history['loss'],'r',linewidth=3.0)
plt.plot(H.history['val_loss'],'b',linewidth=3.0)
plt.legend(['Training loss', 'Validation Loss'],fontsize=18)
plt.xlabel('Epochs ',fontsize=16)
plt.ylabel('Loss',fontsize=16)
plt.title('Loss Curves',fontsize=16)

#Plot the Accuracy Curves
plt.figure(figsize=[12,12])
plt.plot(H.history['accuracy'],'r',linewidth=3.0)
plt.plot(H.history['val_accuracy'],'b',linewidth=3.0)
plt.legend(['Training Accuracy', 'Validation Accuracy'],fontsize=18)
plt.xlabel('Epochs ',fontsize=16)
plt.ylabel('Accuracy',fontsize=16)
plt.title('Accuracy Curves',fontsize=16)

plt.show()

model.save('mnist_fc_epoch20.h5')

